<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script type="text/javascript">
//    function sum () {var num2 = 2 }
     // 函数数据类型的在预解释阶段，会讲声明和定义同时执行；浏览器会讲函数的定义以字符串的形式存在一个新的命名空间，堆内存中。
    // 学习关键词： 预解释
    // 预解释：在浏览器解析执行代码的时候，会提前把带var 和 function 代码声明或定义，提前放在作用域的最前面执行。
    // 分为两步执行的 。 1、 声明这个变量  2、给num 这个变量赋值 2
//
//    console.log(sum);
//    var num3 = 3;
//    function sum () {
//        var num2 = 2;
//        console.log(num3);
//    }
//    sum();
//    console.log(num2);
    // 预解释中需要注意的坑。
    //1、 私有作用域可以访问全局作用域里边声明或定义的变量，全局作用域不能访问和调用私有作用域里边声明的方法和变量;
    //2、 var 和 function 在预解释阶段有一定的区别，var 的只是提前声明，只做了变量提升，并没有赋值.function 声明和定义是同时进行的，为了方便他在不同的地方调用，但是现在还没有在执行，浏览器会开辟一个全新的命名空间（堆内存），以字符串的形象保存这些代码；
    // 3、在函数执行中，函数的形参也进行预解释

                // 相当于var param1
    function sum (param1, param2) {
        console.log(arguments);
        console.log(param1);
        var num = 1;
        param1 = 1;
        function method  () { var num3 = 2}
        return param1 + param2;
    }
        // 总结分析这个函数的执行过程
        // 1、首先新进行预解释。形参和函数私有作用域中带var 和function 进行提升。
        // 2、代码开始从上往下执行，给形参赋值。代码接着往下执行

        // 3、return 下面的代码不执行了，返回值，返回产出
    // 4、在判断体中，无论判断是否成立。里面的代码都进行预解释,但是不进行定义。
//    console.log(num);
//    var obj = '';
//    if (obj) {
//        var num = 2;
//    }
//    console.log(num);
    // 5、在函数表达式中，等号右边function 不进行预解释


    // method();
    // method2();
    // 函数表达式
//    var method = function () {
//        console.log('不进行预解释');
//    };
//    // 命名函数
//    function method2 () {
//        var num = 2;
//        console.log(num)
//    };
    //6、 自执行函数不进行预解释。但是在他执行的时候开辟的栈内存，进行预解释。
//    (function () {
//        console.log(num);
//        var num  = 6;
//        console.log(num);
//    })()
//    //7、在函数执行的时候，return后边紧紧跟着的不进行预解释。但是在return下面的依然进行预解释，但是不执行不赋值。
//    function sum () {
//        console.log(num4);
//        var num1 = 1;
//        var num2 = 2;
//        return function (num) {
//            console.log(num3)
//            var num3 = num1 + num2;
//            console.log(num3)
//        };
//        var num4 = 4;
//        console.log(num4);
//    }
//    sum();
// 8、在预解释中，变量名不能重复，变量当前的作用域中，同名的变量声明，会覆盖之前的声明。
//    fn();
//    function fn() {
//        //console.log(1)
//    }
//    fn();
//    var fn = 2; // fn = 2;
//    //fn(); // fn is not a function;
//    function  fn () {
//       // console.log(3)
//    }
//    console.log(fn);
//    fn();
// 9、不带var的变量，不进行预解释，相当于给window动态添加了一个属性 zfpx；
//   当代码执行到这的时候，才进行的创建变量并赋值这个过程，所以在创建之前的调用，会报错，变量is not defined；
    zfpx = '珠峰培训';
console.log(window.zfpx);
console.log(zfpx)
</script>